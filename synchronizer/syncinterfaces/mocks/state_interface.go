// Code generated by mockery. DO NOT EDIT.

package mock_syncinterfaces

import (
	context "context"

	common "github.com/ethereum/go-ethereum/common"

	entities "github.com/0xPolygonHermez/zkevm-synchronizer-l1/state/entities"

	mock "github.com/stretchr/testify/mock"

	model "github.com/0xPolygonHermez/zkevm-synchronizer-l1/state/model"
)

// StateInterface is an autogenerated mock type for the StateInterface type
type StateInterface struct {
	mock.Mock
}

type StateInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *StateInterface) EXPECT() *StateInterface_Expecter {
	return &StateInterface_Expecter{mock: &_m.Mock}
}

// AddBlock provides a mock function with given fields: ctx, block, dbTx
func (_m *StateInterface) AddBlock(ctx context.Context, block *entities.L1Block, dbTx entities.Tx) error {
	ret := _m.Called(ctx, block, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddBlock")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entities.L1Block, entities.Tx) error); ok {
		r0 = rf(ctx, block, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StateInterface_AddBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddBlock'
type StateInterface_AddBlock_Call struct {
	*mock.Call
}

// AddBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - block *entities.L1Block
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) AddBlock(ctx interface{}, block interface{}, dbTx interface{}) *StateInterface_AddBlock_Call {
	return &StateInterface_AddBlock_Call{Call: _e.mock.On("AddBlock", ctx, block, dbTx)}
}

func (_c *StateInterface_AddBlock_Call) Run(run func(ctx context.Context, block *entities.L1Block, dbTx entities.Tx)) *StateInterface_AddBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*entities.L1Block), args[2].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_AddBlock_Call) Return(_a0 error) *StateInterface_AddBlock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StateInterface_AddBlock_Call) RunAndReturn(run func(context.Context, *entities.L1Block, entities.Tx) error) *StateInterface_AddBlock_Call {
	_c.Call.Return(run)
	return _c
}

// AddForkID provides a mock function with given fields: ctx, newForkID, dbTx
func (_m *StateInterface) AddForkID(ctx context.Context, newForkID entities.ForkIDInterval, dbTx entities.Tx) error {
	ret := _m.Called(ctx, newForkID, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddForkID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, entities.ForkIDInterval, entities.Tx) error); ok {
		r0 = rf(ctx, newForkID, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StateInterface_AddForkID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddForkID'
type StateInterface_AddForkID_Call struct {
	*mock.Call
}

// AddForkID is a helper method to define mock.On call
//   - ctx context.Context
//   - newForkID entities.ForkIDInterval
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) AddForkID(ctx interface{}, newForkID interface{}, dbTx interface{}) *StateInterface_AddForkID_Call {
	return &StateInterface_AddForkID_Call{Call: _e.mock.On("AddForkID", ctx, newForkID, dbTx)}
}

func (_c *StateInterface_AddForkID_Call) Run(run func(ctx context.Context, newForkID entities.ForkIDInterval, dbTx entities.Tx)) *StateInterface_AddForkID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(entities.ForkIDInterval), args[2].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_AddForkID_Call) Return(_a0 error) *StateInterface_AddForkID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StateInterface_AddForkID_Call) RunAndReturn(run func(context.Context, entities.ForkIDInterval, entities.Tx) error) *StateInterface_AddForkID_Call {
	_c.Call.Return(run)
	return _c
}

// AddL1InfoTreeLeafAndAssignIndex provides a mock function with given fields: ctx, exitRoot, dbTx
func (_m *StateInterface) AddL1InfoTreeLeafAndAssignIndex(ctx context.Context, exitRoot *entities.L1InfoTreeLeaf, dbTx entities.Tx) (*entities.L1InfoTreeLeaf, error) {
	ret := _m.Called(ctx, exitRoot, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddL1InfoTreeLeafAndAssignIndex")
	}

	var r0 *entities.L1InfoTreeLeaf
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *entities.L1InfoTreeLeaf, entities.Tx) (*entities.L1InfoTreeLeaf, error)); ok {
		return rf(ctx, exitRoot, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *entities.L1InfoTreeLeaf, entities.Tx) *entities.L1InfoTreeLeaf); ok {
		r0 = rf(ctx, exitRoot, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.L1InfoTreeLeaf)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *entities.L1InfoTreeLeaf, entities.Tx) error); ok {
		r1 = rf(ctx, exitRoot, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateInterface_AddL1InfoTreeLeafAndAssignIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddL1InfoTreeLeafAndAssignIndex'
type StateInterface_AddL1InfoTreeLeafAndAssignIndex_Call struct {
	*mock.Call
}

// AddL1InfoTreeLeafAndAssignIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - exitRoot *entities.L1InfoTreeLeaf
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) AddL1InfoTreeLeafAndAssignIndex(ctx interface{}, exitRoot interface{}, dbTx interface{}) *StateInterface_AddL1InfoTreeLeafAndAssignIndex_Call {
	return &StateInterface_AddL1InfoTreeLeafAndAssignIndex_Call{Call: _e.mock.On("AddL1InfoTreeLeafAndAssignIndex", ctx, exitRoot, dbTx)}
}

func (_c *StateInterface_AddL1InfoTreeLeafAndAssignIndex_Call) Run(run func(ctx context.Context, exitRoot *entities.L1InfoTreeLeaf, dbTx entities.Tx)) *StateInterface_AddL1InfoTreeLeafAndAssignIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*entities.L1InfoTreeLeaf), args[2].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_AddL1InfoTreeLeafAndAssignIndex_Call) Return(_a0 *entities.L1InfoTreeLeaf, _a1 error) *StateInterface_AddL1InfoTreeLeafAndAssignIndex_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StateInterface_AddL1InfoTreeLeafAndAssignIndex_Call) RunAndReturn(run func(context.Context, *entities.L1InfoTreeLeaf, entities.Tx) (*entities.L1InfoTreeLeaf, error)) *StateInterface_AddL1InfoTreeLeafAndAssignIndex_Call {
	_c.Call.Return(run)
	return _c
}

// AddOnReorgCallback provides a mock function with given fields: f
func (_m *StateInterface) AddOnReorgCallback(f func(model.ReorgExecutionResult)) {
	_m.Called(f)
}

// StateInterface_AddOnReorgCallback_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddOnReorgCallback'
type StateInterface_AddOnReorgCallback_Call struct {
	*mock.Call
}

// AddOnReorgCallback is a helper method to define mock.On call
//   - f func(model.ReorgExecutionResult)
func (_e *StateInterface_Expecter) AddOnReorgCallback(f interface{}) *StateInterface_AddOnReorgCallback_Call {
	return &StateInterface_AddOnReorgCallback_Call{Call: _e.mock.On("AddOnReorgCallback", f)}
}

func (_c *StateInterface_AddOnReorgCallback_Call) Run(run func(f func(model.ReorgExecutionResult))) *StateInterface_AddOnReorgCallback_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(func(model.ReorgExecutionResult)))
	})
	return _c
}

func (_c *StateInterface_AddOnReorgCallback_Call) Return() *StateInterface_AddOnReorgCallback_Call {
	_c.Call.Return()
	return _c
}

func (_c *StateInterface_AddOnReorgCallback_Call) RunAndReturn(run func(func(model.ReorgExecutionResult))) *StateInterface_AddOnReorgCallback_Call {
	_c.Call.Return(run)
	return _c
}

// BeginTransaction provides a mock function with given fields: ctx
func (_m *StateInterface) BeginTransaction(ctx context.Context) (entities.Tx, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for BeginTransaction")
	}

	var r0 entities.Tx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (entities.Tx, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) entities.Tx); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(entities.Tx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateInterface_BeginTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BeginTransaction'
type StateInterface_BeginTransaction_Call struct {
	*mock.Call
}

// BeginTransaction is a helper method to define mock.On call
//   - ctx context.Context
func (_e *StateInterface_Expecter) BeginTransaction(ctx interface{}) *StateInterface_BeginTransaction_Call {
	return &StateInterface_BeginTransaction_Call{Call: _e.mock.On("BeginTransaction", ctx)}
}

func (_c *StateInterface_BeginTransaction_Call) Run(run func(ctx context.Context)) *StateInterface_BeginTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *StateInterface_BeginTransaction_Call) Return(_a0 entities.Tx, _a1 error) *StateInterface_BeginTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StateInterface_BeginTransaction_Call) RunAndReturn(run func(context.Context) (entities.Tx, error)) *StateInterface_BeginTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteReorg provides a mock function with given fields: ctx, reorgRequest, dbTx
func (_m *StateInterface) ExecuteReorg(ctx context.Context, reorgRequest model.ReorgRequest, dbTx entities.Tx) model.ReorgExecutionResult {
	ret := _m.Called(ctx, reorgRequest, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteReorg")
	}

	var r0 model.ReorgExecutionResult
	if rf, ok := ret.Get(0).(func(context.Context, model.ReorgRequest, entities.Tx) model.ReorgExecutionResult); ok {
		r0 = rf(ctx, reorgRequest, dbTx)
	} else {
		r0 = ret.Get(0).(model.ReorgExecutionResult)
	}

	return r0
}

// StateInterface_ExecuteReorg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteReorg'
type StateInterface_ExecuteReorg_Call struct {
	*mock.Call
}

// ExecuteReorg is a helper method to define mock.On call
//   - ctx context.Context
//   - reorgRequest model.ReorgRequest
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) ExecuteReorg(ctx interface{}, reorgRequest interface{}, dbTx interface{}) *StateInterface_ExecuteReorg_Call {
	return &StateInterface_ExecuteReorg_Call{Call: _e.mock.On("ExecuteReorg", ctx, reorgRequest, dbTx)}
}

func (_c *StateInterface_ExecuteReorg_Call) Run(run func(ctx context.Context, reorgRequest model.ReorgRequest, dbTx entities.Tx)) *StateInterface_ExecuteReorg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.ReorgRequest), args[2].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_ExecuteReorg_Call) Return(_a0 model.ReorgExecutionResult) *StateInterface_ExecuteReorg_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StateInterface_ExecuteReorg_Call) RunAndReturn(run func(context.Context, model.ReorgRequest, entities.Tx) model.ReorgExecutionResult) *StateInterface_ExecuteReorg_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteRollbackBatches provides a mock function with given fields: ctx, rollbackBatchesRequest, dbTx
func (_m *StateInterface) ExecuteRollbackBatches(ctx context.Context, rollbackBatchesRequest model.RollbackBatchesRequest, dbTx entities.Tx) (*model.RollbackBatchesExecutionResult, error) {
	ret := _m.Called(ctx, rollbackBatchesRequest, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteRollbackBatches")
	}

	var r0 *model.RollbackBatchesExecutionResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.RollbackBatchesRequest, entities.Tx) (*model.RollbackBatchesExecutionResult, error)); ok {
		return rf(ctx, rollbackBatchesRequest, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.RollbackBatchesRequest, entities.Tx) *model.RollbackBatchesExecutionResult); ok {
		r0 = rf(ctx, rollbackBatchesRequest, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.RollbackBatchesExecutionResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.RollbackBatchesRequest, entities.Tx) error); ok {
		r1 = rf(ctx, rollbackBatchesRequest, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateInterface_ExecuteRollbackBatches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteRollbackBatches'
type StateInterface_ExecuteRollbackBatches_Call struct {
	*mock.Call
}

// ExecuteRollbackBatches is a helper method to define mock.On call
//   - ctx context.Context
//   - rollbackBatchesRequest model.RollbackBatchesRequest
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) ExecuteRollbackBatches(ctx interface{}, rollbackBatchesRequest interface{}, dbTx interface{}) *StateInterface_ExecuteRollbackBatches_Call {
	return &StateInterface_ExecuteRollbackBatches_Call{Call: _e.mock.On("ExecuteRollbackBatches", ctx, rollbackBatchesRequest, dbTx)}
}

func (_c *StateInterface_ExecuteRollbackBatches_Call) Run(run func(ctx context.Context, rollbackBatchesRequest model.RollbackBatchesRequest, dbTx entities.Tx)) *StateInterface_ExecuteRollbackBatches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.RollbackBatchesRequest), args[2].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_ExecuteRollbackBatches_Call) Return(_a0 *model.RollbackBatchesExecutionResult, _a1 error) *StateInterface_ExecuteRollbackBatches_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StateInterface_ExecuteRollbackBatches_Call) RunAndReturn(run func(context.Context, model.RollbackBatchesRequest, entities.Tx) (*model.RollbackBatchesExecutionResult, error)) *StateInterface_ExecuteRollbackBatches_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockByNumber provides a mock function with given fields: ctx, blockNumber, dbTx
func (_m *StateInterface) GetBlockByNumber(ctx context.Context, blockNumber uint64, dbTx entities.Tx) (*entities.L1Block, error) {
	ret := _m.Called(ctx, blockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockByNumber")
	}

	var r0 *entities.L1Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, entities.Tx) (*entities.L1Block, error)); ok {
		return rf(ctx, blockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, entities.Tx) *entities.L1Block); ok {
		r0 = rf(ctx, blockNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.L1Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, entities.Tx) error); ok {
		r1 = rf(ctx, blockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateInterface_GetBlockByNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockByNumber'
type StateInterface_GetBlockByNumber_Call struct {
	*mock.Call
}

// GetBlockByNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber uint64
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) GetBlockByNumber(ctx interface{}, blockNumber interface{}, dbTx interface{}) *StateInterface_GetBlockByNumber_Call {
	return &StateInterface_GetBlockByNumber_Call{Call: _e.mock.On("GetBlockByNumber", ctx, blockNumber, dbTx)}
}

func (_c *StateInterface_GetBlockByNumber_Call) Run(run func(ctx context.Context, blockNumber uint64, dbTx entities.Tx)) *StateInterface_GetBlockByNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_GetBlockByNumber_Call) Return(_a0 *entities.L1Block, _a1 error) *StateInterface_GetBlockByNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StateInterface_GetBlockByNumber_Call) RunAndReturn(run func(context.Context, uint64, entities.Tx) (*entities.L1Block, error)) *StateInterface_GetBlockByNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetFirstUncheckedBlock provides a mock function with given fields: ctx, fromBlockNumber, dbTx
func (_m *StateInterface) GetFirstUncheckedBlock(ctx context.Context, fromBlockNumber uint64, dbTx entities.Tx) (*entities.L1Block, error) {
	ret := _m.Called(ctx, fromBlockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetFirstUncheckedBlock")
	}

	var r0 *entities.L1Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, entities.Tx) (*entities.L1Block, error)); ok {
		return rf(ctx, fromBlockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, entities.Tx) *entities.L1Block); ok {
		r0 = rf(ctx, fromBlockNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.L1Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, entities.Tx) error); ok {
		r1 = rf(ctx, fromBlockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateInterface_GetFirstUncheckedBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFirstUncheckedBlock'
type StateInterface_GetFirstUncheckedBlock_Call struct {
	*mock.Call
}

// GetFirstUncheckedBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - fromBlockNumber uint64
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) GetFirstUncheckedBlock(ctx interface{}, fromBlockNumber interface{}, dbTx interface{}) *StateInterface_GetFirstUncheckedBlock_Call {
	return &StateInterface_GetFirstUncheckedBlock_Call{Call: _e.mock.On("GetFirstUncheckedBlock", ctx, fromBlockNumber, dbTx)}
}

func (_c *StateInterface_GetFirstUncheckedBlock_Call) Run(run func(ctx context.Context, fromBlockNumber uint64, dbTx entities.Tx)) *StateInterface_GetFirstUncheckedBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_GetFirstUncheckedBlock_Call) Return(_a0 *entities.L1Block, _a1 error) *StateInterface_GetFirstUncheckedBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StateInterface_GetFirstUncheckedBlock_Call) RunAndReturn(run func(context.Context, uint64, entities.Tx) (*entities.L1Block, error)) *StateInterface_GetFirstUncheckedBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetForkIDByBatchNumber provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StateInterface) GetForkIDByBatchNumber(ctx context.Context, batchNumber uint64, dbTx entities.Tx) uint64 {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetForkIDByBatchNumber")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, uint64, entities.Tx) uint64); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// StateInterface_GetForkIDByBatchNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetForkIDByBatchNumber'
type StateInterface_GetForkIDByBatchNumber_Call struct {
	*mock.Call
}

// GetForkIDByBatchNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) GetForkIDByBatchNumber(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StateInterface_GetForkIDByBatchNumber_Call {
	return &StateInterface_GetForkIDByBatchNumber_Call{Call: _e.mock.On("GetForkIDByBatchNumber", ctx, batchNumber, dbTx)}
}

func (_c *StateInterface_GetForkIDByBatchNumber_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx entities.Tx)) *StateInterface_GetForkIDByBatchNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_GetForkIDByBatchNumber_Call) Return(_a0 uint64) *StateInterface_GetForkIDByBatchNumber_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StateInterface_GetForkIDByBatchNumber_Call) RunAndReturn(run func(context.Context, uint64, entities.Tx) uint64) *StateInterface_GetForkIDByBatchNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetForkIDByBlockNumber provides a mock function with given fields: ctx, blockNumber, dbTx
func (_m *StateInterface) GetForkIDByBlockNumber(ctx context.Context, blockNumber uint64, dbTx entities.Tx) uint64 {
	ret := _m.Called(ctx, blockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetForkIDByBlockNumber")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, uint64, entities.Tx) uint64); ok {
		r0 = rf(ctx, blockNumber, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// StateInterface_GetForkIDByBlockNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetForkIDByBlockNumber'
type StateInterface_GetForkIDByBlockNumber_Call struct {
	*mock.Call
}

// GetForkIDByBlockNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber uint64
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) GetForkIDByBlockNumber(ctx interface{}, blockNumber interface{}, dbTx interface{}) *StateInterface_GetForkIDByBlockNumber_Call {
	return &StateInterface_GetForkIDByBlockNumber_Call{Call: _e.mock.On("GetForkIDByBlockNumber", ctx, blockNumber, dbTx)}
}

func (_c *StateInterface_GetForkIDByBlockNumber_Call) Run(run func(ctx context.Context, blockNumber uint64, dbTx entities.Tx)) *StateInterface_GetForkIDByBlockNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_GetForkIDByBlockNumber_Call) Return(_a0 uint64) *StateInterface_GetForkIDByBlockNumber_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StateInterface_GetForkIDByBlockNumber_Call) RunAndReturn(run func(context.Context, uint64, entities.Tx) uint64) *StateInterface_GetForkIDByBlockNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetL1InfoLeafPerIndex provides a mock function with given fields: ctx, L1InfoTreeIndex, dbTx
func (_m *StateInterface) GetL1InfoLeafPerIndex(ctx context.Context, L1InfoTreeIndex uint32, dbTx entities.Tx) (*entities.L1InfoTreeLeaf, error) {
	ret := _m.Called(ctx, L1InfoTreeIndex, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetL1InfoLeafPerIndex")
	}

	var r0 *entities.L1InfoTreeLeaf
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, entities.Tx) (*entities.L1InfoTreeLeaf, error)); ok {
		return rf(ctx, L1InfoTreeIndex, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, entities.Tx) *entities.L1InfoTreeLeaf); ok {
		r0 = rf(ctx, L1InfoTreeIndex, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.L1InfoTreeLeaf)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, entities.Tx) error); ok {
		r1 = rf(ctx, L1InfoTreeIndex, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateInterface_GetL1InfoLeafPerIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetL1InfoLeafPerIndex'
type StateInterface_GetL1InfoLeafPerIndex_Call struct {
	*mock.Call
}

// GetL1InfoLeafPerIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - L1InfoTreeIndex uint32
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) GetL1InfoLeafPerIndex(ctx interface{}, L1InfoTreeIndex interface{}, dbTx interface{}) *StateInterface_GetL1InfoLeafPerIndex_Call {
	return &StateInterface_GetL1InfoLeafPerIndex_Call{Call: _e.mock.On("GetL1InfoLeafPerIndex", ctx, L1InfoTreeIndex, dbTx)}
}

func (_c *StateInterface_GetL1InfoLeafPerIndex_Call) Run(run func(ctx context.Context, L1InfoTreeIndex uint32, dbTx entities.Tx)) *StateInterface_GetL1InfoLeafPerIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint32), args[2].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_GetL1InfoLeafPerIndex_Call) Return(_a0 *entities.L1InfoTreeLeaf, _a1 error) *StateInterface_GetL1InfoLeafPerIndex_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StateInterface_GetL1InfoLeafPerIndex_Call) RunAndReturn(run func(context.Context, uint32, entities.Tx) (*entities.L1InfoTreeLeaf, error)) *StateInterface_GetL1InfoLeafPerIndex_Call {
	_c.Call.Return(run)
	return _c
}

// GetL1InfoRootPerLeafIndex provides a mock function with given fields: ctx, L1InfoTreeIndex, dbTx
func (_m *StateInterface) GetL1InfoRootPerLeafIndex(ctx context.Context, L1InfoTreeIndex uint32, dbTx entities.Tx) (common.Hash, error) {
	ret := _m.Called(ctx, L1InfoTreeIndex, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetL1InfoRootPerLeafIndex")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, entities.Tx) (common.Hash, error)); ok {
		return rf(ctx, L1InfoTreeIndex, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, entities.Tx) common.Hash); ok {
		r0 = rf(ctx, L1InfoTreeIndex, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, entities.Tx) error); ok {
		r1 = rf(ctx, L1InfoTreeIndex, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateInterface_GetL1InfoRootPerLeafIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetL1InfoRootPerLeafIndex'
type StateInterface_GetL1InfoRootPerLeafIndex_Call struct {
	*mock.Call
}

// GetL1InfoRootPerLeafIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - L1InfoTreeIndex uint32
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) GetL1InfoRootPerLeafIndex(ctx interface{}, L1InfoTreeIndex interface{}, dbTx interface{}) *StateInterface_GetL1InfoRootPerLeafIndex_Call {
	return &StateInterface_GetL1InfoRootPerLeafIndex_Call{Call: _e.mock.On("GetL1InfoRootPerLeafIndex", ctx, L1InfoTreeIndex, dbTx)}
}

func (_c *StateInterface_GetL1InfoRootPerLeafIndex_Call) Run(run func(ctx context.Context, L1InfoTreeIndex uint32, dbTx entities.Tx)) *StateInterface_GetL1InfoRootPerLeafIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint32), args[2].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_GetL1InfoRootPerLeafIndex_Call) Return(_a0 common.Hash, _a1 error) *StateInterface_GetL1InfoRootPerLeafIndex_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StateInterface_GetL1InfoRootPerLeafIndex_Call) RunAndReturn(run func(context.Context, uint32, entities.Tx) (common.Hash, error)) *StateInterface_GetL1InfoRootPerLeafIndex_Call {
	_c.Call.Return(run)
	return _c
}

// GetL1InfoTreeLeaves provides a mock function with given fields: ctx, indexLeaves, dbTx
func (_m *StateInterface) GetL1InfoTreeLeaves(ctx context.Context, indexLeaves []uint32, dbTx entities.Tx) (map[uint32]entities.L1InfoTreeLeaf, error) {
	ret := _m.Called(ctx, indexLeaves, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetL1InfoTreeLeaves")
	}

	var r0 map[uint32]entities.L1InfoTreeLeaf
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []uint32, entities.Tx) (map[uint32]entities.L1InfoTreeLeaf, error)); ok {
		return rf(ctx, indexLeaves, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []uint32, entities.Tx) map[uint32]entities.L1InfoTreeLeaf); ok {
		r0 = rf(ctx, indexLeaves, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[uint32]entities.L1InfoTreeLeaf)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []uint32, entities.Tx) error); ok {
		r1 = rf(ctx, indexLeaves, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateInterface_GetL1InfoTreeLeaves_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetL1InfoTreeLeaves'
type StateInterface_GetL1InfoTreeLeaves_Call struct {
	*mock.Call
}

// GetL1InfoTreeLeaves is a helper method to define mock.On call
//   - ctx context.Context
//   - indexLeaves []uint32
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) GetL1InfoTreeLeaves(ctx interface{}, indexLeaves interface{}, dbTx interface{}) *StateInterface_GetL1InfoTreeLeaves_Call {
	return &StateInterface_GetL1InfoTreeLeaves_Call{Call: _e.mock.On("GetL1InfoTreeLeaves", ctx, indexLeaves, dbTx)}
}

func (_c *StateInterface_GetL1InfoTreeLeaves_Call) Run(run func(ctx context.Context, indexLeaves []uint32, dbTx entities.Tx)) *StateInterface_GetL1InfoTreeLeaves_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]uint32), args[2].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_GetL1InfoTreeLeaves_Call) Return(_a0 map[uint32]entities.L1InfoTreeLeaf, _a1 error) *StateInterface_GetL1InfoTreeLeaves_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StateInterface_GetL1InfoTreeLeaves_Call) RunAndReturn(run func(context.Context, []uint32, entities.Tx) (map[uint32]entities.L1InfoTreeLeaf, error)) *StateInterface_GetL1InfoTreeLeaves_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastBlock provides a mock function with given fields: ctx, dbTx
func (_m *StateInterface) GetLastBlock(ctx context.Context, dbTx entities.Tx) (*entities.L1Block, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastBlock")
	}

	var r0 *entities.L1Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, entities.Tx) (*entities.L1Block, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, entities.Tx) *entities.L1Block); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.L1Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, entities.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateInterface_GetLastBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastBlock'
type StateInterface_GetLastBlock_Call struct {
	*mock.Call
}

// GetLastBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) GetLastBlock(ctx interface{}, dbTx interface{}) *StateInterface_GetLastBlock_Call {
	return &StateInterface_GetLastBlock_Call{Call: _e.mock.On("GetLastBlock", ctx, dbTx)}
}

func (_c *StateInterface_GetLastBlock_Call) Run(run func(ctx context.Context, dbTx entities.Tx)) *StateInterface_GetLastBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_GetLastBlock_Call) Return(_a0 *entities.L1Block, _a1 error) *StateInterface_GetLastBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StateInterface_GetLastBlock_Call) RunAndReturn(run func(context.Context, entities.Tx) (*entities.L1Block, error)) *StateInterface_GetLastBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetLeafsByL1InfoRoot provides a mock function with given fields: ctx, l1InfoRoot, dbTx
func (_m *StateInterface) GetLeafsByL1InfoRoot(ctx context.Context, l1InfoRoot common.Hash, dbTx entities.Tx) ([]entities.L1InfoTreeLeaf, error) {
	ret := _m.Called(ctx, l1InfoRoot, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLeafsByL1InfoRoot")
	}

	var r0 []entities.L1InfoTreeLeaf
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, entities.Tx) ([]entities.L1InfoTreeLeaf, error)); ok {
		return rf(ctx, l1InfoRoot, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, entities.Tx) []entities.L1InfoTreeLeaf); ok {
		r0 = rf(ctx, l1InfoRoot, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entities.L1InfoTreeLeaf)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, entities.Tx) error); ok {
		r1 = rf(ctx, l1InfoRoot, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateInterface_GetLeafsByL1InfoRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLeafsByL1InfoRoot'
type StateInterface_GetLeafsByL1InfoRoot_Call struct {
	*mock.Call
}

// GetLeafsByL1InfoRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - l1InfoRoot common.Hash
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) GetLeafsByL1InfoRoot(ctx interface{}, l1InfoRoot interface{}, dbTx interface{}) *StateInterface_GetLeafsByL1InfoRoot_Call {
	return &StateInterface_GetLeafsByL1InfoRoot_Call{Call: _e.mock.On("GetLeafsByL1InfoRoot", ctx, l1InfoRoot, dbTx)}
}

func (_c *StateInterface_GetLeafsByL1InfoRoot_Call) Run(run func(ctx context.Context, l1InfoRoot common.Hash, dbTx entities.Tx)) *StateInterface_GetLeafsByL1InfoRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_GetLeafsByL1InfoRoot_Call) Return(_a0 []entities.L1InfoTreeLeaf, _a1 error) *StateInterface_GetLeafsByL1InfoRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StateInterface_GetLeafsByL1InfoRoot_Call) RunAndReturn(run func(context.Context, common.Hash, entities.Tx) ([]entities.L1InfoTreeLeaf, error)) *StateInterface_GetLeafsByL1InfoRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetPreviousBlock provides a mock function with given fields: ctx, offset, dbTx
func (_m *StateInterface) GetPreviousBlock(ctx context.Context, offset uint64, dbTx entities.Tx) (*entities.L1Block, error) {
	ret := _m.Called(ctx, offset, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetPreviousBlock")
	}

	var r0 *entities.L1Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, entities.Tx) (*entities.L1Block, error)); ok {
		return rf(ctx, offset, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, entities.Tx) *entities.L1Block); ok {
		r0 = rf(ctx, offset, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.L1Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, entities.Tx) error); ok {
		r1 = rf(ctx, offset, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateInterface_GetPreviousBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPreviousBlock'
type StateInterface_GetPreviousBlock_Call struct {
	*mock.Call
}

// GetPreviousBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - offset uint64
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) GetPreviousBlock(ctx interface{}, offset interface{}, dbTx interface{}) *StateInterface_GetPreviousBlock_Call {
	return &StateInterface_GetPreviousBlock_Call{Call: _e.mock.On("GetPreviousBlock", ctx, offset, dbTx)}
}

func (_c *StateInterface_GetPreviousBlock_Call) Run(run func(ctx context.Context, offset uint64, dbTx entities.Tx)) *StateInterface_GetPreviousBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_GetPreviousBlock_Call) Return(_a0 *entities.L1Block, _a1 error) *StateInterface_GetPreviousBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StateInterface_GetPreviousBlock_Call) RunAndReturn(run func(context.Context, uint64, entities.Tx) (*entities.L1Block, error)) *StateInterface_GetPreviousBlock_Call {
	_c.Call.Return(run)
	return _c
}

// OnSequencedBatchesOnL1 provides a mock function with given fields: ctx, seq, dbTx
func (_m *StateInterface) OnSequencedBatchesOnL1(ctx context.Context, seq model.SequenceOfBatches, dbTx entities.Tx) error {
	ret := _m.Called(ctx, seq, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for OnSequencedBatchesOnL1")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, model.SequenceOfBatches, entities.Tx) error); ok {
		r0 = rf(ctx, seq, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StateInterface_OnSequencedBatchesOnL1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnSequencedBatchesOnL1'
type StateInterface_OnSequencedBatchesOnL1_Call struct {
	*mock.Call
}

// OnSequencedBatchesOnL1 is a helper method to define mock.On call
//   - ctx context.Context
//   - seq model.SequenceOfBatches
//   - dbTx entities.Tx
func (_e *StateInterface_Expecter) OnSequencedBatchesOnL1(ctx interface{}, seq interface{}, dbTx interface{}) *StateInterface_OnSequencedBatchesOnL1_Call {
	return &StateInterface_OnSequencedBatchesOnL1_Call{Call: _e.mock.On("OnSequencedBatchesOnL1", ctx, seq, dbTx)}
}

func (_c *StateInterface_OnSequencedBatchesOnL1_Call) Run(run func(ctx context.Context, seq model.SequenceOfBatches, dbTx entities.Tx)) *StateInterface_OnSequencedBatchesOnL1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.SequenceOfBatches), args[2].(entities.Tx))
	})
	return _c
}

func (_c *StateInterface_OnSequencedBatchesOnL1_Call) Return(_a0 error) *StateInterface_OnSequencedBatchesOnL1_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StateInterface_OnSequencedBatchesOnL1_Call) RunAndReturn(run func(context.Context, model.SequenceOfBatches, entities.Tx) error) *StateInterface_OnSequencedBatchesOnL1_Call {
	_c.Call.Return(run)
	return _c
}

// NewStateInterface creates a new instance of StateInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStateInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *StateInterface {
	mock := &StateInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
