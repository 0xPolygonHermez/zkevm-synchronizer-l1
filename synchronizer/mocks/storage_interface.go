// Code generated by mockery. DO NOT EDIT.

package mock_synchronizer

import (
	context "context"

	common "github.com/ethereum/go-ethereum/common"

	mock "github.com/stretchr/testify/mock"

	pgstorage "github.com/0xPolygonHermez/zkevm-synchronizer-l1/storage/pgstorage"

	pgx "github.com/jackc/pgx/v4"
)

// StorageInterface is an autogenerated mock type for the StorageInterface type
type StorageInterface struct {
	mock.Mock
}

type StorageInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *StorageInterface) EXPECT() *StorageInterface_Expecter {
	return &StorageInterface_Expecter{mock: &_m.Mock}
}

// AddBlock provides a mock function with given fields: ctx, block, dbTx
func (_m *StorageInterface) AddBlock(ctx context.Context, block *pgstorage.L1Block, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, block, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddBlock")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *pgstorage.L1Block, pgx.Tx) error); ok {
		r0 = rf(ctx, block, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageInterface_AddBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddBlock'
type StorageInterface_AddBlock_Call struct {
	*mock.Call
}

// AddBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - block *pgstorage.L1Block
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) AddBlock(ctx interface{}, block interface{}, dbTx interface{}) *StorageInterface_AddBlock_Call {
	return &StorageInterface_AddBlock_Call{Call: _e.mock.On("AddBlock", ctx, block, dbTx)}
}

func (_c *StorageInterface_AddBlock_Call) Run(run func(ctx context.Context, block *pgstorage.L1Block, dbTx pgx.Tx)) *StorageInterface_AddBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*pgstorage.L1Block), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_AddBlock_Call) Return(_a0 error) *StorageInterface_AddBlock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageInterface_AddBlock_Call) RunAndReturn(run func(context.Context, *pgstorage.L1Block, pgx.Tx) error) *StorageInterface_AddBlock_Call {
	_c.Call.Return(run)
	return _c
}

// AddForkID provides a mock function with given fields: ctx, forkID, dbTx
func (_m *StorageInterface) AddForkID(ctx context.Context, forkID pgstorage.ForkIDInterval, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, forkID, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddForkID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, pgstorage.ForkIDInterval, pgx.Tx) error); ok {
		r0 = rf(ctx, forkID, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageInterface_AddForkID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddForkID'
type StorageInterface_AddForkID_Call struct {
	*mock.Call
}

// AddForkID is a helper method to define mock.On call
//   - ctx context.Context
//   - forkID pgstorage.ForkIDInterval
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) AddForkID(ctx interface{}, forkID interface{}, dbTx interface{}) *StorageInterface_AddForkID_Call {
	return &StorageInterface_AddForkID_Call{Call: _e.mock.On("AddForkID", ctx, forkID, dbTx)}
}

func (_c *StorageInterface_AddForkID_Call) Run(run func(ctx context.Context, forkID pgstorage.ForkIDInterval, dbTx pgx.Tx)) *StorageInterface_AddForkID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgstorage.ForkIDInterval), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_AddForkID_Call) Return(_a0 error) *StorageInterface_AddForkID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageInterface_AddForkID_Call) RunAndReturn(run func(context.Context, pgstorage.ForkIDInterval, pgx.Tx) error) *StorageInterface_AddForkID_Call {
	_c.Call.Return(run)
	return _c
}

// AddL1InfoTreeLeaf provides a mock function with given fields: ctx, exitRoot, dbTx
func (_m *StorageInterface) AddL1InfoTreeLeaf(ctx context.Context, exitRoot *pgstorage.L1InfoTreeLeaf, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, exitRoot, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddL1InfoTreeLeaf")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *pgstorage.L1InfoTreeLeaf, pgx.Tx) error); ok {
		r0 = rf(ctx, exitRoot, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageInterface_AddL1InfoTreeLeaf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddL1InfoTreeLeaf'
type StorageInterface_AddL1InfoTreeLeaf_Call struct {
	*mock.Call
}

// AddL1InfoTreeLeaf is a helper method to define mock.On call
//   - ctx context.Context
//   - exitRoot *pgstorage.L1InfoTreeLeaf
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) AddL1InfoTreeLeaf(ctx interface{}, exitRoot interface{}, dbTx interface{}) *StorageInterface_AddL1InfoTreeLeaf_Call {
	return &StorageInterface_AddL1InfoTreeLeaf_Call{Call: _e.mock.On("AddL1InfoTreeLeaf", ctx, exitRoot, dbTx)}
}

func (_c *StorageInterface_AddL1InfoTreeLeaf_Call) Run(run func(ctx context.Context, exitRoot *pgstorage.L1InfoTreeLeaf, dbTx pgx.Tx)) *StorageInterface_AddL1InfoTreeLeaf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*pgstorage.L1InfoTreeLeaf), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_AddL1InfoTreeLeaf_Call) Return(_a0 error) *StorageInterface_AddL1InfoTreeLeaf_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageInterface_AddL1InfoTreeLeaf_Call) RunAndReturn(run func(context.Context, *pgstorage.L1InfoTreeLeaf, pgx.Tx) error) *StorageInterface_AddL1InfoTreeLeaf_Call {
	_c.Call.Return(run)
	return _c
}

// AddSequencedBatches provides a mock function with given fields: ctx, sequence, dbTx
func (_m *StorageInterface) AddSequencedBatches(ctx context.Context, sequence pgstorage.SequencedBatches, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, sequence, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddSequencedBatches")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, pgstorage.SequencedBatches, pgx.Tx) error); ok {
		r0 = rf(ctx, sequence, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageInterface_AddSequencedBatches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSequencedBatches'
type StorageInterface_AddSequencedBatches_Call struct {
	*mock.Call
}

// AddSequencedBatches is a helper method to define mock.On call
//   - ctx context.Context
//   - sequence pgstorage.SequencedBatches
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) AddSequencedBatches(ctx interface{}, sequence interface{}, dbTx interface{}) *StorageInterface_AddSequencedBatches_Call {
	return &StorageInterface_AddSequencedBatches_Call{Call: _e.mock.On("AddSequencedBatches", ctx, sequence, dbTx)}
}

func (_c *StorageInterface_AddSequencedBatches_Call) Run(run func(ctx context.Context, sequence pgstorage.SequencedBatches, dbTx pgx.Tx)) *StorageInterface_AddSequencedBatches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgstorage.SequencedBatches), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_AddSequencedBatches_Call) Return(_a0 error) *StorageInterface_AddSequencedBatches_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageInterface_AddSequencedBatches_Call) RunAndReturn(run func(context.Context, pgstorage.SequencedBatches, pgx.Tx) error) *StorageInterface_AddSequencedBatches_Call {
	_c.Call.Return(run)
	return _c
}

// BeginDBTransaction provides a mock function with given fields: ctx
func (_m *StorageInterface) BeginDBTransaction(ctx context.Context) (pgx.Tx, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for BeginDBTransaction")
	}

	var r0 pgx.Tx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (pgx.Tx, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) pgx.Tx); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pgx.Tx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageInterface_BeginDBTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BeginDBTransaction'
type StorageInterface_BeginDBTransaction_Call struct {
	*mock.Call
}

// BeginDBTransaction is a helper method to define mock.On call
//   - ctx context.Context
func (_e *StorageInterface_Expecter) BeginDBTransaction(ctx interface{}) *StorageInterface_BeginDBTransaction_Call {
	return &StorageInterface_BeginDBTransaction_Call{Call: _e.mock.On("BeginDBTransaction", ctx)}
}

func (_c *StorageInterface_BeginDBTransaction_Call) Run(run func(ctx context.Context)) *StorageInterface_BeginDBTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *StorageInterface_BeginDBTransaction_Call) Return(_a0 pgx.Tx, _a1 error) *StorageInterface_BeginDBTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageInterface_BeginDBTransaction_Call) RunAndReturn(run func(context.Context) (pgx.Tx, error)) *StorageInterface_BeginDBTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// BeginStateTransaction provides a mock function with given fields: ctx
func (_m *StorageInterface) BeginStateTransaction(ctx context.Context) (pgx.Tx, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for BeginStateTransaction")
	}

	var r0 pgx.Tx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (pgx.Tx, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) pgx.Tx); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pgx.Tx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageInterface_BeginStateTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BeginStateTransaction'
type StorageInterface_BeginStateTransaction_Call struct {
	*mock.Call
}

// BeginStateTransaction is a helper method to define mock.On call
//   - ctx context.Context
func (_e *StorageInterface_Expecter) BeginStateTransaction(ctx interface{}) *StorageInterface_BeginStateTransaction_Call {
	return &StorageInterface_BeginStateTransaction_Call{Call: _e.mock.On("BeginStateTransaction", ctx)}
}

func (_c *StorageInterface_BeginStateTransaction_Call) Run(run func(ctx context.Context)) *StorageInterface_BeginStateTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *StorageInterface_BeginStateTransaction_Call) Return(_a0 pgx.Tx, _a1 error) *StorageInterface_BeginStateTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageInterface_BeginStateTransaction_Call) RunAndReturn(run func(context.Context) (pgx.Tx, error)) *StorageInterface_BeginStateTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// Commit provides a mock function with given fields: ctx, dbTx
func (_m *StorageInterface) Commit(ctx context.Context, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) error); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageInterface_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type StorageInterface_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) Commit(ctx interface{}, dbTx interface{}) *StorageInterface_Commit_Call {
	return &StorageInterface_Commit_Call{Call: _e.mock.On("Commit", ctx, dbTx)}
}

func (_c *StorageInterface_Commit_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageInterface_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_Commit_Call) Return(_a0 error) *StorageInterface_Commit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageInterface_Commit_Call) RunAndReturn(run func(context.Context, pgx.Tx) error) *StorageInterface_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllL1InfoTreeLeaves provides a mock function with given fields: ctx, dbTx
func (_m *StorageInterface) GetAllL1InfoTreeLeaves(ctx context.Context, dbTx pgx.Tx) ([]pgstorage.L1InfoTreeLeaf, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllL1InfoTreeLeaves")
	}

	var r0 []pgstorage.L1InfoTreeLeaf
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) ([]pgstorage.L1InfoTreeLeaf, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) []pgstorage.L1InfoTreeLeaf); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]pgstorage.L1InfoTreeLeaf)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageInterface_GetAllL1InfoTreeLeaves_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllL1InfoTreeLeaves'
type StorageInterface_GetAllL1InfoTreeLeaves_Call struct {
	*mock.Call
}

// GetAllL1InfoTreeLeaves is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) GetAllL1InfoTreeLeaves(ctx interface{}, dbTx interface{}) *StorageInterface_GetAllL1InfoTreeLeaves_Call {
	return &StorageInterface_GetAllL1InfoTreeLeaves_Call{Call: _e.mock.On("GetAllL1InfoTreeLeaves", ctx, dbTx)}
}

func (_c *StorageInterface_GetAllL1InfoTreeLeaves_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageInterface_GetAllL1InfoTreeLeaves_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_GetAllL1InfoTreeLeaves_Call) Return(_a0 []pgstorage.L1InfoTreeLeaf, _a1 error) *StorageInterface_GetAllL1InfoTreeLeaves_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageInterface_GetAllL1InfoTreeLeaves_Call) RunAndReturn(run func(context.Context, pgx.Tx) ([]pgstorage.L1InfoTreeLeaf, error)) *StorageInterface_GetAllL1InfoTreeLeaves_Call {
	_c.Call.Return(run)
	return _c
}

// GetForkIDs provides a mock function with given fields: ctx, dbTx
func (_m *StorageInterface) GetForkIDs(ctx context.Context, dbTx pgx.Tx) ([]pgstorage.ForkIDInterval, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetForkIDs")
	}

	var r0 []pgstorage.ForkIDInterval
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) ([]pgstorage.ForkIDInterval, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) []pgstorage.ForkIDInterval); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]pgstorage.ForkIDInterval)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageInterface_GetForkIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetForkIDs'
type StorageInterface_GetForkIDs_Call struct {
	*mock.Call
}

// GetForkIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) GetForkIDs(ctx interface{}, dbTx interface{}) *StorageInterface_GetForkIDs_Call {
	return &StorageInterface_GetForkIDs_Call{Call: _e.mock.On("GetForkIDs", ctx, dbTx)}
}

func (_c *StorageInterface_GetForkIDs_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageInterface_GetForkIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_GetForkIDs_Call) Return(_a0 []pgstorage.ForkIDInterval, _a1 error) *StorageInterface_GetForkIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageInterface_GetForkIDs_Call) RunAndReturn(run func(context.Context, pgx.Tx) ([]pgstorage.ForkIDInterval, error)) *StorageInterface_GetForkIDs_Call {
	_c.Call.Return(run)
	return _c
}

// GetL1InfoLeafPerIndex provides a mock function with given fields: ctx, L1InfoTreeIndex, dbTx
func (_m *StorageInterface) GetL1InfoLeafPerIndex(ctx context.Context, L1InfoTreeIndex uint32, dbTx pgx.Tx) (*pgstorage.L1InfoTreeLeaf, error) {
	ret := _m.Called(ctx, L1InfoTreeIndex, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetL1InfoLeafPerIndex")
	}

	var r0 *pgstorage.L1InfoTreeLeaf
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, pgx.Tx) (*pgstorage.L1InfoTreeLeaf, error)); ok {
		return rf(ctx, L1InfoTreeIndex, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, pgx.Tx) *pgstorage.L1InfoTreeLeaf); ok {
		r0 = rf(ctx, L1InfoTreeIndex, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pgstorage.L1InfoTreeLeaf)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, pgx.Tx) error); ok {
		r1 = rf(ctx, L1InfoTreeIndex, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageInterface_GetL1InfoLeafPerIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetL1InfoLeafPerIndex'
type StorageInterface_GetL1InfoLeafPerIndex_Call struct {
	*mock.Call
}

// GetL1InfoLeafPerIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - L1InfoTreeIndex uint32
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) GetL1InfoLeafPerIndex(ctx interface{}, L1InfoTreeIndex interface{}, dbTx interface{}) *StorageInterface_GetL1InfoLeafPerIndex_Call {
	return &StorageInterface_GetL1InfoLeafPerIndex_Call{Call: _e.mock.On("GetL1InfoLeafPerIndex", ctx, L1InfoTreeIndex, dbTx)}
}

func (_c *StorageInterface_GetL1InfoLeafPerIndex_Call) Run(run func(ctx context.Context, L1InfoTreeIndex uint32, dbTx pgx.Tx)) *StorageInterface_GetL1InfoLeafPerIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint32), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_GetL1InfoLeafPerIndex_Call) Return(_a0 *pgstorage.L1InfoTreeLeaf, _a1 error) *StorageInterface_GetL1InfoLeafPerIndex_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageInterface_GetL1InfoLeafPerIndex_Call) RunAndReturn(run func(context.Context, uint32, pgx.Tx) (*pgstorage.L1InfoTreeLeaf, error)) *StorageInterface_GetL1InfoLeafPerIndex_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastBlock provides a mock function with given fields: ctx, dbTx
func (_m *StorageInterface) GetLastBlock(ctx context.Context, dbTx pgx.Tx) (*pgstorage.L1Block, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastBlock")
	}

	var r0 *pgstorage.L1Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (*pgstorage.L1Block, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) *pgstorage.L1Block); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pgstorage.L1Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageInterface_GetLastBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastBlock'
type StorageInterface_GetLastBlock_Call struct {
	*mock.Call
}

// GetLastBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) GetLastBlock(ctx interface{}, dbTx interface{}) *StorageInterface_GetLastBlock_Call {
	return &StorageInterface_GetLastBlock_Call{Call: _e.mock.On("GetLastBlock", ctx, dbTx)}
}

func (_c *StorageInterface_GetLastBlock_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageInterface_GetLastBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_GetLastBlock_Call) Return(_a0 *pgstorage.L1Block, _a1 error) *StorageInterface_GetLastBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageInterface_GetLastBlock_Call) RunAndReturn(run func(context.Context, pgx.Tx) (*pgstorage.L1Block, error)) *StorageInterface_GetLastBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestL1InfoTreeLeaf provides a mock function with given fields: ctx, dbTx
func (_m *StorageInterface) GetLatestL1InfoTreeLeaf(ctx context.Context, dbTx pgx.Tx) (*pgstorage.L1InfoTreeLeaf, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestL1InfoTreeLeaf")
	}

	var r0 *pgstorage.L1InfoTreeLeaf
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (*pgstorage.L1InfoTreeLeaf, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) *pgstorage.L1InfoTreeLeaf); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pgstorage.L1InfoTreeLeaf)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageInterface_GetLatestL1InfoTreeLeaf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestL1InfoTreeLeaf'
type StorageInterface_GetLatestL1InfoTreeLeaf_Call struct {
	*mock.Call
}

// GetLatestL1InfoTreeLeaf is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) GetLatestL1InfoTreeLeaf(ctx interface{}, dbTx interface{}) *StorageInterface_GetLatestL1InfoTreeLeaf_Call {
	return &StorageInterface_GetLatestL1InfoTreeLeaf_Call{Call: _e.mock.On("GetLatestL1InfoTreeLeaf", ctx, dbTx)}
}

func (_c *StorageInterface_GetLatestL1InfoTreeLeaf_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageInterface_GetLatestL1InfoTreeLeaf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_GetLatestL1InfoTreeLeaf_Call) Return(_a0 *pgstorage.L1InfoTreeLeaf, _a1 error) *StorageInterface_GetLatestL1InfoTreeLeaf_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageInterface_GetLatestL1InfoTreeLeaf_Call) RunAndReturn(run func(context.Context, pgx.Tx) (*pgstorage.L1InfoTreeLeaf, error)) *StorageInterface_GetLatestL1InfoTreeLeaf_Call {
	_c.Call.Return(run)
	return _c
}

// GetLeafsByL1InfoRoot provides a mock function with given fields: ctx, l1InfoRoot, dbTx
func (_m *StorageInterface) GetLeafsByL1InfoRoot(ctx context.Context, l1InfoRoot common.Hash, dbTx pgx.Tx) ([]pgstorage.L1InfoTreeLeaf, error) {
	ret := _m.Called(ctx, l1InfoRoot, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLeafsByL1InfoRoot")
	}

	var r0 []pgstorage.L1InfoTreeLeaf
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) ([]pgstorage.L1InfoTreeLeaf, error)); ok {
		return rf(ctx, l1InfoRoot, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) []pgstorage.L1InfoTreeLeaf); ok {
		r0 = rf(ctx, l1InfoRoot, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]pgstorage.L1InfoTreeLeaf)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r1 = rf(ctx, l1InfoRoot, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageInterface_GetLeafsByL1InfoRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLeafsByL1InfoRoot'
type StorageInterface_GetLeafsByL1InfoRoot_Call struct {
	*mock.Call
}

// GetLeafsByL1InfoRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - l1InfoRoot common.Hash
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) GetLeafsByL1InfoRoot(ctx interface{}, l1InfoRoot interface{}, dbTx interface{}) *StorageInterface_GetLeafsByL1InfoRoot_Call {
	return &StorageInterface_GetLeafsByL1InfoRoot_Call{Call: _e.mock.On("GetLeafsByL1InfoRoot", ctx, l1InfoRoot, dbTx)}
}

func (_c *StorageInterface_GetLeafsByL1InfoRoot_Call) Run(run func(ctx context.Context, l1InfoRoot common.Hash, dbTx pgx.Tx)) *StorageInterface_GetLeafsByL1InfoRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_GetLeafsByL1InfoRoot_Call) Return(_a0 []pgstorage.L1InfoTreeLeaf, _a1 error) *StorageInterface_GetLeafsByL1InfoRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageInterface_GetLeafsByL1InfoRoot_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) ([]pgstorage.L1InfoTreeLeaf, error)) *StorageInterface_GetLeafsByL1InfoRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetPreviousBlock provides a mock function with given fields: ctx, offset, dbTx
func (_m *StorageInterface) GetPreviousBlock(ctx context.Context, offset uint64, dbTx pgx.Tx) (*pgstorage.L1Block, error) {
	ret := _m.Called(ctx, offset, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetPreviousBlock")
	}

	var r0 *pgstorage.L1Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*pgstorage.L1Block, error)); ok {
		return rf(ctx, offset, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *pgstorage.L1Block); ok {
		r0 = rf(ctx, offset, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pgstorage.L1Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, offset, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageInterface_GetPreviousBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPreviousBlock'
type StorageInterface_GetPreviousBlock_Call struct {
	*mock.Call
}

// GetPreviousBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - offset uint64
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) GetPreviousBlock(ctx interface{}, offset interface{}, dbTx interface{}) *StorageInterface_GetPreviousBlock_Call {
	return &StorageInterface_GetPreviousBlock_Call{Call: _e.mock.On("GetPreviousBlock", ctx, offset, dbTx)}
}

func (_c *StorageInterface_GetPreviousBlock_Call) Run(run func(ctx context.Context, offset uint64, dbTx pgx.Tx)) *StorageInterface_GetPreviousBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_GetPreviousBlock_Call) Return(_a0 *pgstorage.L1Block, _a1 error) *StorageInterface_GetPreviousBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageInterface_GetPreviousBlock_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*pgstorage.L1Block, error)) *StorageInterface_GetPreviousBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetSequenceByBatchNumber provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageInterface) GetSequenceByBatchNumber(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) (*pgstorage.SequencedBatches, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetSequenceByBatchNumber")
	}

	var r0 *pgstorage.SequencedBatches
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*pgstorage.SequencedBatches, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *pgstorage.SequencedBatches); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pgstorage.SequencedBatches)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageInterface_GetSequenceByBatchNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSequenceByBatchNumber'
type StorageInterface_GetSequenceByBatchNumber_Call struct {
	*mock.Call
}

// GetSequenceByBatchNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) GetSequenceByBatchNumber(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageInterface_GetSequenceByBatchNumber_Call {
	return &StorageInterface_GetSequenceByBatchNumber_Call{Call: _e.mock.On("GetSequenceByBatchNumber", ctx, batchNumber, dbTx)}
}

func (_c *StorageInterface_GetSequenceByBatchNumber_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageInterface_GetSequenceByBatchNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_GetSequenceByBatchNumber_Call) Return(_a0 *pgstorage.SequencedBatches, _a1 error) *StorageInterface_GetSequenceByBatchNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageInterface_GetSequenceByBatchNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*pgstorage.SequencedBatches, error)) *StorageInterface_GetSequenceByBatchNumber_Call {
	_c.Call.Return(run)
	return _c
}

// Reset provides a mock function with given fields: ctx, blockNumber, dbTx
func (_m *StorageInterface) Reset(ctx context.Context, blockNumber uint64, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, blockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for Reset")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) error); ok {
		r0 = rf(ctx, blockNumber, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageInterface_Reset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reset'
type StorageInterface_Reset_Call struct {
	*mock.Call
}

// Reset is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) Reset(ctx interface{}, blockNumber interface{}, dbTx interface{}) *StorageInterface_Reset_Call {
	return &StorageInterface_Reset_Call{Call: _e.mock.On("Reset", ctx, blockNumber, dbTx)}
}

func (_c *StorageInterface_Reset_Call) Run(run func(ctx context.Context, blockNumber uint64, dbTx pgx.Tx)) *StorageInterface_Reset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_Reset_Call) Return(_a0 error) *StorageInterface_Reset_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageInterface_Reset_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) error) *StorageInterface_Reset_Call {
	_c.Call.Return(run)
	return _c
}

// Rollback provides a mock function with given fields: ctx, dbTx
func (_m *StorageInterface) Rollback(ctx context.Context, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for Rollback")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) error); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageInterface_Rollback_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rollback'
type StorageInterface_Rollback_Call struct {
	*mock.Call
}

// Rollback is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) Rollback(ctx interface{}, dbTx interface{}) *StorageInterface_Rollback_Call {
	return &StorageInterface_Rollback_Call{Call: _e.mock.On("Rollback", ctx, dbTx)}
}

func (_c *StorageInterface_Rollback_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageInterface_Rollback_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_Rollback_Call) Return(_a0 error) *StorageInterface_Rollback_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageInterface_Rollback_Call) RunAndReturn(run func(context.Context, pgx.Tx) error) *StorageInterface_Rollback_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateForkID provides a mock function with given fields: ctx, forkID, dbTx
func (_m *StorageInterface) UpdateForkID(ctx context.Context, forkID pgstorage.ForkIDInterval, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, forkID, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for UpdateForkID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, pgstorage.ForkIDInterval, pgx.Tx) error); ok {
		r0 = rf(ctx, forkID, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageInterface_UpdateForkID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateForkID'
type StorageInterface_UpdateForkID_Call struct {
	*mock.Call
}

// UpdateForkID is a helper method to define mock.On call
//   - ctx context.Context
//   - forkID pgstorage.ForkIDInterval
//   - dbTx pgx.Tx
func (_e *StorageInterface_Expecter) UpdateForkID(ctx interface{}, forkID interface{}, dbTx interface{}) *StorageInterface_UpdateForkID_Call {
	return &StorageInterface_UpdateForkID_Call{Call: _e.mock.On("UpdateForkID", ctx, forkID, dbTx)}
}

func (_c *StorageInterface_UpdateForkID_Call) Run(run func(ctx context.Context, forkID pgstorage.ForkIDInterval, dbTx pgx.Tx)) *StorageInterface_UpdateForkID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgstorage.ForkIDInterval), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageInterface_UpdateForkID_Call) Return(_a0 error) *StorageInterface_UpdateForkID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageInterface_UpdateForkID_Call) RunAndReturn(run func(context.Context, pgstorage.ForkIDInterval, pgx.Tx) error) *StorageInterface_UpdateForkID_Call {
	_c.Call.Return(run)
	return _c
}

// NewStorageInterface creates a new instance of StorageInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStorageInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *StorageInterface {
	mock := &StorageInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
